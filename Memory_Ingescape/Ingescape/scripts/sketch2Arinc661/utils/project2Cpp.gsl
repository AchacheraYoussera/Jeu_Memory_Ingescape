.ignorecase = 0
.template 0

if !defined(project)
    abort "Error: can't find <project> tag, {script: $(gsl.script), file: $(gsl.filename)}."
endif


function typeToQtType (type)
   if (type = "STRING")
       return "QString"
   elsif (type = "INTEGER")
       return "int"
   elsif (type = "DOUBLE")
       return "double"
   elsif (type = "BOOL")
       return "bool"
   elsif (type = "IMPULSION")
       return ""
   elsif (type = "DATA")
       return "QByteArray"
   else
        #echo "could not convert type $(type) : return it as is"
       return "$(type)"
   endif
endfunction typeToQtType


function typeToQtArgument (type)
   if (type = "STRING")
       return "const QString&"
   elsif (type = "INTEGER")
       return "int"
   elsif (type = "DOUBLE")
       return "double"
   elsif (type = "BOOL")
       return "bool"
   elsif (type = "IMPULSION")
       return ""
   elsif (type = "DATA")
       return "const QByteArray&"
   else
        #echo "could not convert type $(type) : return it as is"
       return "$(type)"
   endif
endfunction typeToQtArgument


function typeToIGSType (type)
   if (type = "STRING")
       return "IGS_STRING_T"
   elsif (type = "INTEGER")
       return "IGS_INTEGER_T"
   elsif (type = "DOUBLE")
       return "IGS_DOUBLE_T"
   elsif (type = "BOOL")
       return "IGS_BOOL_T"
   elsif (type = "IMPULSION")
       return "IGS_IMPULSION_T"
   elsif (type = "DATA")
       return "IGS_DATA_T"
   endif
endfunction typeToIGSType


function nameToCName (name)
    return '$("$(name:c)":Neat)'
endfunction nameToCName


function graphicAppHasScreen(app)
    for app.page
        if count(page.screen) > 0
            return 1
        endif
    endfor
    return 0
endfunction graphicAppHasScreen


function copyFile(sourceFilePath, destinationFilePath)
    if file.exists(my.destinationFilePath)
        file.delete(my.destinationFilePath)
    endif
    if (file.copy(my.sourceFilePath, my.destinationFilePath, "b", my.error) = -1)
        echo "Failed to copy file $(my.sourceFilePath) at $(my.destinationFilePath): $(my.error)"
    endif
endfunction copyFile


function numberOfScreens(app)
    my.result = 0
    for my.app.page
.       for page.screen
            my.result += 1
        endfor
    endfor
    return my.result
endfunction numberOfScreens


function qmlModuleName(value)
    if regexp.match("([^\\.]+)\\.(.*)$", my.value, leftPart, rightPart)
        return "$(leftPart:Pascal)." + qmlModuleName(rightPart)
    else
        return "$(my.value:Pascal)"
    endif
endfunction qmlModuleName


function toLowercase(value)
    my.value = "$(my.value:Pascal)"
    return "$(my.value:lower)"
endfunction 


.endtemplate

.template 1
.
.####################################################################################
.echo "Creating directories structure ..."
.directory.create("builds/cmake/modules/windows/")
.if (global.project_useI2Quick)
.   directory.create("internal")
.endif
.directory.create(global.project_sourceFolder)
.directory.create("$(global.project_sourceFolder)/qml")
.if global.project_hasGraphics
.   directory.create(global.project_graphicFolder)
.endif
.
.####################################################################################
.echo "Generating .gitignore ..."
.output ".gitignore"
# Ignore compiled files
*.o


# Ignore Qt user-specific files
*.pro.user
*.pro.user.*
*.qmlproject.user
*.qmlproject.user.*
*.qbs.user
*.qbs.user.*
*.txt.user


# Ignore Qt generated files
\.qmake.cache
\.qmake.stash
*.moc
moc_*.cpp
moc_*.h
qrc_*.cpp
ui_*.h


# Ignore Qt default build directory
*build-*


#Xcode files
*.xcodeproj
#Ignore build Xcode Path
build-xcode
Debug
Release
SharedPrecompiledHeaders
*.build
#Ignore Xcode User Pref
xcuserdata
xcshareddata
.
.####################################################################################
.if (global.project_useI2Quick)
.echo "Generating .gitmodules ..."
.output ".gitmodules"
[submodule "internal/I2Quick"]
        path = internal/I2Quick
        url = ssh://git@gitlab.ingescape.com:22222/ingescape/tools/i2quickqt6.git
.endif

.
.####################################################################################
.if (global.project_useI2Quick)
.echo "Generating bootstrap.sh ..."
.output "bootstrap.sh"
#!/bin/sh

set -e

[[ ! -d .git ]] && echo "Initializing a git repository first..." && git init

git config -f .gitmodules --get-regexp '^submodule\..*\.path\$' |
    while read path_key path
    do
        url_key=\$(echo \$path_key | sed 's/\.path/.url/')
        url=\$(git config -f .gitmodules --get "\$url_key")
        branch_key=\$(echo $path_key | sed 's/\.path/.branch/')
        branch=\$(git config -f .gitmodules --get "\$branch_key" 2> /dev/null || true)

        if [[ -z \$branch ]]
        then
            git submodule add \$url \$path
        else
            git submodule add -b \$branch \$url \$path
        fi
    done
.endif
.
.####################################################################################
.echo "Generating CMakeLists.txt ..."
.output "CMakeLists.txt"
cmake_minimum_required(VERSION 3.16)

# Project name can only contains upper and lower case letters, numbers,
# the underscore character (_), dot(.), plus(+) and minus(-).
project($(global.project_name:c) LANGUAGES C CXX)

set(CMAKE_OSX_ARCHITECTURES "x86_64;arm64")

# Define Qt cmake modules path if not already done
if (DEFINED ENV{Qt6_DIR} AND NOT DEFINED Qt6_DIR)
    STRING(REPLACE "\\\"" "" Qt6_DIR $ENV{Qt6_DIR})
endif ()

# Override default release flags to not define NDEBUG, which CMake sets by default for Release builds
# NB: The NDEBUG flag compile out all assert() calls, skipping whatever was done in the assert call (function call, computation, etc.)
# It changes the compiled code from the source code and we don't want that.
if (NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
   # Enable assertions in release mode
   message(STATUS "Enable C asserts in release mode (instead of noop)")
   if (MSVC)
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE})
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO ${CMAKE_CXX_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL ${CMAKE_CXX_FLAGS_MINSIZEREL})

       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE})
       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO ${CMAKE_CXX_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL ${CMAKE_CXX_FLAGS_MINSIZEREL})

       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_RELEASE ${CMAKE_C_FLAGS_RELEASE})
       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO ${CMAKE_C_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL ${CMAKE_C_FLAGS_MINSIZEREL})

       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_RELEASE ${CMAKE_C_FLAGS_RELEASE})
       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO ${CMAKE_C_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL ${CMAKE_C_FLAGS_MINSIZEREL})
   else()
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL}")

       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_MINSIZEREL}")
   endif()
endif()

add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/src)
.
.####################################################################################
.echo "Generating README.md ..."
.output "README.md"
# $(global.project_name)

.if global.project_useI2Quick
Once generated, you can setup a git repository with these commands:

    chmod +x bootstrap.sh
    ./bootstrap.sh

.endif
This project uses the QtFramework. It is recommended to use the QtCreator IDE and the
CMakeLists.txt at the root of the project to edit the sources and compile the solution
while in development.

To compile from the command line, you can use CMake directly. However, you will have to specify
the path to your Qt6 installation via the `Qt6_DIR` environment variable. Depending on which OS you are compiling,
you may also have to define the `Qt6Xxx_DIR` paths to the Qt components.

If environment variables are missing, CMake will output error messages telling you which ones must be defined.

As an example, here is a short Unix script that defines the path `_DIR` environment variables for all installed
Qt6 components so that CMake can find them. This script should work for macOS and Linux environments.
You will have to adapt the `/path/to/Qt/` to point to your Qt installation directory and change the version
and platform to what's installed on your machine.

```bash
for d in \$(find /path/to/Qt/<version>/<platform>/lib/cmake -depth 1 -type d); do export `basename ${d}`_DIR=${d}; done
```

The structure of this directory and the specifics of each folder are listed below.
For more in depth detail on each folder, navigate to that folder to view its specific README.md

```
├──  README.md
├──  builds
.if (global.project_useI2Quick)
├──  internal
.endif
├──  src
```

The **builds** folder contains utility files for build (CMake, etc.).

.if (global.project_useI2Quick)
The **internal** folder contains other GIT repositories of Ingenuity i/o as sub-modules (I2Quick, etc.).

.endif
The **src** folder contains the source files of the application.

.
.####################################################################################
.echo "Generating src/$(global.project_name:pascal).pro ..."
.output "src/$(global.project_name:pascal).pro"
#####################################################################
#
# Generic (multi-platform) rules
#
#####################################################################

VERSION_MAJOR = 1
VERSION_MINOR = 2
VERSION_PATCH = 3

TARGET = $(global.project_name:pascal)
VERSION = $${VERSION_MAJOR}.$${VERSION_MINOR}.$${VERSION_PATCH}

# To get the version in our C++ code
DEFINES += "VERSION=\\\\\\"$$VERSION\\\\\\""
DEFINES += "APP_NAME=\\\\\\"$$TARGET\\\\\\""

QT += widgets qml quick quick-private quickcontrols2impl-private svg core-private testlib concurrent

CONFIG += c++17 precompile_header
PRECOMPILED_HEADER = stable.h

# To build temp files (*.o, moc_*.cpp and qrc_*.cpp) in a temp dir
OBJECTS_DIR = tmp
MOC_DIR = tmp
RCC_DIR = tmp
UI_DIR = tmp
QMLCACHE_DIR = tmp


# The following define makes your compiler emit warnings if you use
# any Qt feature that has been marked deprecated (the exact warnings
# depend on your compiler). Refer to the documentation for the
# deprecated API to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0


# Project sources, headers and resources
SOURCES += \\
    main.cpp \\
.if global.project_hasGraphics & !(global.project_useI2Quick)
    qmlhotreloader.cpp \\
.endif
.if global.project_useQmlInstrument
    qmlinstrument.cpp
.endif

HEADERS += \\
.if global.project_hasGraphics & !(global.project_useI2Quick)
    qmlhotreloader.h \\
.endif
.if global.project_useQmlInstrument
    qmlinstrument.h
.endif

RESOURCES += \\
    $(global.project_name:camel,lower).qrc

OTHER_FILES += \\
    # ...

.if global.project_useIngescape & global.project_embedIngescape
CONFIG(debug, debug|release) {
    win32 {
        DEFINES += INGESCAPE
    }

    # Include ingescape library
    !include(../../../ingescape/builds/qt/ingescape.pri) {
        error(Could not load ingescape.pri)
    }
}
.endif

# Additional include paths
.if (global.project_useI2Quick)
INCLUDEPATH += ../internal/I2Quick/src/I2Quick
.else
# ...
.endif

# Additional import path used to resolve QML modules in Qt Creator's code model
QML_IMPORT_PATH += qml

.if (global.project_useI2Quick)
# Embed I2Quick into our library
DEFINES += I2QUICK_BUILD_LIBRARY
!include(../internal/I2Quick/src/I2Quick/I2Quick.pri) {
    error(Could not load I2Quick.pri)
}
.endif
.if (global.project_hasPackages)
# Include UML packages
!include(./packages/packages.pri) {
    error(Could not load packages.pri)
}

.endif
.if (global.project_hasGraphics)
# Include graphics QML sub projects
!include(./graphics/I2SketchQuick/src/I2SketchQuick/I2SketchQuick.pri) {
    error(Could not load I2SketchQuick.pri)
}
.   for project.graphics
.       for graphics.graphic
.           for graphic.app
!include(./graphics/$(app.name:Pascal)App/$(app.name:Pascal)App.pri) {
    error(Could not load $(app.name:Pascal)App.pri)
}
.           endfor
.           for graphic.library
!include(./graphics/$(library.name:Pascal)/$(library.name:Pascal).pri) {
    error(Could not load $(library.name:Pascal).pri)
}
.           endfor
.       endfor
.   endfor
.endif
.if (global.project_hasAgents)
# Include agents
!include(./agents/agents.pri) {
    error(Could not load agents.pri)
}
.endif


#####################################################################
#
# Platform specific rules
#
#####################################################################
mac {
    message($${TARGET} - macOS specific rules)

    QMAKE_APPLE_DEVICE_ARCHS = x86_64 arm64

.if (global.project_useIngescape & global.project_embedIngescape)
    CONFIG(release, debug|release) {
.endif
.if global.project_useIngescape
    INCLUDEPATH += /usr/local/include

    LIBS += /usr/local/lib/libczmq.dylib
    LIBS += /usr/local/lib/libzyre.dylib
    LIBS += /usr/local/lib/libsodium.dylib
    LIBS += /usr/local/lib/libingescape.dylib
    LIBS += -framework CoreFoundation

    librariesToCopy.files += /usr/local/lib/libzmq.5.dylib
    librariesToCopy.files += /usr/local/lib/libczmq.4.dylib
    librariesToCopy.files += /usr/local/lib/libzyre.2.dylib
    librariesToCopy.files += /usr/local/lib/libsodium.23.dylib
    librariesToCopy.files += /usr/local/lib/libingescape.4.dylib

    librariesToCopy.path = Contents/Frameworks

    QMAKE_BUNDLE_DATA += librariesToCopy
.endif

.if (global.project_useIngescape & global.project_embedIngescape)
    }
.endif

    CONFIG(release, debug|release) {
        QMAKE_POST_LINK += $$quote(cd `dirname \$(QMAKE)` && macdeployqt $${OUT_PWD}/$${TARGET}.app -qmldir=$${PWD} $$escape_expand(\\n\\t))
    }


    # TODO Uncomment when there is an icon for the app
    #ICON = icon.icns
}

win32 {
    message($${TARGET} - Windows specific rules)

.if global.project_useIngescape & !global.project_embedIngescape
    INCLUDEPATH += $\$(ProgramFiles)/ingescape/library/include
    LIBS += -L$\$(ProgramFiles)/ingescape/library/lib/ -lzyre -lczmq -llibsodium -lingescape

.endif
    CONFIG(release, debug|release) {
.if global.project_useIngescape & global.project_embedIngescape
    LIBS += -L$\$(ProgramFiles)/ingescape/library/lib/ -lzyre -lczmq -llibsodium -lingescape
.endif
        QMAKE_POST_LINK += $$shell_quote($$shell_path($$[QT_INSTALL_BINS]/windeployqt)) $${OUT_PWD}/$${TARGET}.exe -xml -concurrent -printsupport -qmldir=$${PWD} $$escape_expand(\\n\\t)
    }

    LIBS += -lWtsapi32 -luser32 -lshell32 -lws2_32

    librariesToCopy.path = $${OUT_PWD}
    INSTALLS += librariesToCopy

    # TODO Uncomment when there is an icon for the app
    #RC_ICONS = icon.ico

    QMAKE_TARGET_PRODUCT = $${TARGET}
.if (defined(definition->description) & string.length(definition->description))
    QMAKE_TARGET_DESCRIPTION = $(definition->description)
.endif
    QMAKE_TARGET_COPYRIGHT = $(global.project_copyright)
}

.####################################################################################
.echo "Copying NSIS.template.in into builds/cmake/modules/windows/NSIS.template.in ..."
.if (file.copy("resources/NSIS.template.in", "builds/cmake/modules/windows/NSIS.template.in", "t", error) = -1)
.echo "failed to copy file NSIS.template.in at builds/cmake/modules/windows/NSIS.template.in: $(error)"
.endif
.
.####################################################################################
.echo "Generating builds/cmake/modules/windows/Windeploy.cmake..."
.output "builds/cmake/modules/windows/Windeploy.cmake"
find_package(Qt6Core REQUIRED)

# Retrieve the absolute path to qmake and then use that path to find
# the windeployqt binary
get_target_property(_qmake_executable Qt6::qmake IMPORTED_LOCATION)
get_filename_component(_qt_bin_dir "${_qmake_executable}" DIRECTORY)
find_program(WINDEPLOYQT_EXECUTABLE windeployqt HINTS "${_qt_bin_dir}")

# Running this with MSVC 2019 requires CMake 3.18+
if((MSVC_VERSION VERSION_EQUAL 1920 OR MSVC_VERSION VERSION_GREATER 1920)
        AND CMAKE_VERSION VERSION_LESS "3.18")
    message(WARNING "Deploying with MSVC 2019+ requires CMake 3.18+")
endif()

# Add commands that copy the Qt runtime to the target's output directory after
# build and install the Qt runtime to the specified directory
function(windeployqt target qml_src_dir)
    # Run windeployqt immediately after build
    add_custom_command(TARGET ${target} POST_BUILD
        COMMAND "${CMAKE_COMMAND}" -E
            env PATH="${_qt_bin_dir}" "${WINDEPLOYQT_EXECUTABLE}"
                --verbose 0
                -xml -concurrent -printsupport -qmldir=\\"${qml_src_dir}\\"
                \\"$<TARGET_FILE:${target}>\\"
    )

    # install(CODE ...) doesn't support generator expressions, but
    # file(GENERATE ...) does - store the path in a file
    file(GENERATE OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${target}_path"
        CONTENT "$<TARGET_FILE:${target}>"
        CONDITION $<AND:$<COMPILE_LANGUAGE:CXX>,$<CONFIG:Release>>
    )

    # Before installation, run a series of commands that copy each of the Qt
    # runtime files to the appropriate directory for installation
    install(CODE
        "
        file(READ \\"${CMAKE_CURRENT_BINARY_DIR}/${target}_path\\" _file)
        execute_process(
            COMMAND \\"${CMAKE_COMMAND}\\" -E
                env PATH=\\"${_qt_bin_dir}\\" \\"${WINDEPLOYQT_EXECUTABLE}\\"
                    --dry-run
                    -xml -concurrent -printsupport -qmldir=\\"${qml_src_dir}\\"
                    --list mapping
                    \\${_file}
            OUTPUT_VARIABLE _output
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
        separate_arguments(_files WINDOWS_COMMAND \\${_output})
        while(_files)
            list(GET _files 0 _src)
            list(GET _files 1 _dest)
            execute_process(
                COMMAND \\"${CMAKE_COMMAND}\\" -E
                    copy \\${_src} \\"\\${CMAKE_INSTALL_PREFIX}/\\${_dest}\\"
            )
            list(REMOVE_AT _files 0 1)
        endwhile()
        "
    )

    # windeployqt doesn't work correctly with the system runtime libraries,
    # so we fall back to one of CMake's own modules for copying them over
    set(CMAKE_INSTALL_UCRT_LIBRARIES TRUE)
    set(CMAKE_INSTALL_SYSTEM_RUNTIME_DESTINATION .)
    include(InstallRequiredSystemLibraries)
    foreach(lib ${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS})
        get_filename_component(filename "${lib}" NAME)
        add_custom_command(TARGET ${target} POST_BUILD
            COMMAND "${CMAKE_COMMAND}" -E
                copy_if_different "${lib}" \\"$<TARGET_FILE_DIR:${target}>\\"
        )
    endforeach()

endfunction()

mark_as_advanced(WINDEPLOYQT_EXECUTABLE)

.
.####################################################################################
.echo "Generating builds/cmake/modules/windows/$(global.project_name:pascal,lower)_version.rc.in ..."
.output "builds/cmake/modules/windows/$(global.project_name:pascal,lower)_version.rc.in"
/////////////////////////////////////////////////////////////////////////////
//
// Version
//
#include <winresrc.h>

#define VER_FILEVERSION             @APP_VERSION_MAJOR@,@APP_VERSION_MINOR@,0,@APP_VERSION_PATCH@
#define VER_FILEVERSION_STR         "@APP_VERSION_MAJOR@.@APP_VERSION_MINOR@.0.@APP_VERSION_PATCH@\0"

#define VER_PRODUCTVERSION          @APP_VERSION_MAJOR@,@APP_VERSION_MINOR@,@APP_VERSION_PATCH@,0
#define VER_PRODUCTVERSION_STR      "@APP_VERSION_MAJOR@.@APP_VERSION_MINOR@.@APP_VERSION_PATCH@\0"

#define COPYRIGHT                   "$(global.project_copyright)"
#define APP_NAME                    "$(global.project_name)"

VS_VERSION_INFO VERSIONINFO
FILEVERSION     VER_FILEVERSION
PRODUCTVERSION  VER_PRODUCTVERSION
FILEOS          VOS__WINDOWS32
FILETYPE        VFT_APP
FILESUBTYPE     VFT2_UNKNOWN
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "CompanyName",      "Ingenuity I/O"
            VALUE "FileDescription",  APP_NAME
            VALUE "FileVersion",      VER_FILEVERSION_STR
            VALUE "LegalCopyright",   COPYRIGHT
            VALUE "ProductName",      APP_NAME
            VALUE "ProductVersion",   VER_PRODUCTVERSION_STR
        END
    END

    BLOCK "VarFileInfo"
    BEGIN
        /* The following line should only be modified for localized versions.     */
        /* It consists of any number of WORD,WORD pairs, with each pair           */
        /* describing a language,codepage combination supported by the file.      */
        /*                                                                        */
        /* For example, a file might have values "0x409,1252" indicating that it  */
        /* supports English language (0x409) in the Windows ANSI codepage (1252). */

        VALUE "Translation", 0x409, 1252
    END
END

/* Uncomment when there is an icon for the app         */
/* IDI_ICON1        ICON    DISCARDABLE     "icon.ico" */


.
.
.####################################################################################
.echo "Generating src/CMakeLists.txt..."
.output "src/CMakeLists.txt"
cmake_minimum_required(VERSION 3.16)

macro(_find_dll_from_lib _LIB _DLL)
    # Get path and file name from lib file
    get_filename_component(_PATH_TO_FILE ${${_LIB}} DIRECTORY)
    get_filename_component(_FILE_NAME ${${_LIB}} NAME)
    string(REGEX REPLACE "\\\\.[^.]*$" "" _FILE_WITHOUT_EXT ${_FILE_NAME})

	# Check if DLL file exists next to the given LIB file
    find_file(${_FILE_WITHOUT_EXT}_DLL_FILE "${_FILE_WITHOUT_EXT}${CMAKE_SHARED_LIBRARY_SUFFIX}" PATHS ${_PATH_TO_FILE} NO_DEFAULT_PATH)
    if (${${_FILE_WITHOUT_EXT}_DLL_FILE} STREQUAL ${_FILE_WITHOUT_EXT}_DLL_FILE-NOTFOUND)
        message(DEBUG "File ${_PATH_TO_FILE}/${_FILE_WITHOUT_EXT}${CMAKE_SHARED_LIBRARY_SUFFIX} not found")

        # Check if libXXX.dll exists next to the given LIB file
        find_file(${_FILE_WITHOUT_EXT}_DLL_FILE "lib${_FILE_WITHOUT_EXT}${CMAKE_SHARED_LIBRARY_SUFFIX}" PATHS ${_PATH_TO_FILE} NO_DEFAULT_PATH)
        if (${${_FILE_WITHOUT_EXT}_DLL_FILE} STREQUAL ${_FILE_WITHOUT_EXT}_DLL_FILE-NOTFOUND)
            message(DEBUG "File ${_PATH_TO_FILE}/lib${_FILE_WITHOUT_EXT}${CMAKE_SHARED_LIBRARY_SUFFIX} not found")

            # Check if the DLL file exists in ../bin relatively to the given LIB file
            get_filename_component(_PATH_TO_FILE ${_PATH_TO_FILE} DIRECTORY)
            set(_PATH_TO_FILE ${_PATH_TO_FILE}/bin)
            find_file(${_FILE_WITHOUT_EXT}_DLL_FILE "${_FILE_WITHOUT_EXT}${CMAKE_SHARED_LIBRARY_SUFFIX}" PATHS ${_PATH_TO_FILE} NO_DEFAULT_PATH)
            if (${${_FILE_WITHOUT_EXT}_DLL_FILE} STREQUAL ${_FILE_WITHOUT_EXT}_DLL_FILE-NOTFOUND)
              message(DEBUG "File ${_PATH_TO_FILE}/${_FILE_WITHOUT_EXT}${CMAKE_SHARED_LIBRARY_SUFFIX} not found")

              # Check if libXXX.dll exists in ../bin relatively to the given LIB file
              find_file(${_FILE_WITHOUT_EXT}_DLL_FILE "lib${_FILE_WITHOUT_EXT}${CMAKE_SHARED_LIBRARY_SUFFIX}" PATHS ${_PATH_TO_FILE} NO_DEFAULT_PATH)
            endif()
        endif()
    endif()

    if (NOT ${${_FILE_WITHOUT_EXT}_DLL_FILE} STREQUAL ${_FILE_WITHOUT_EXT}_DLL_FILE-NOTFOUND)
        message("DLL file ${${_FILE_WITHOUT_EXT}_DLL_FILE} found from LIB file ${${_LIB}}")
        set(${_DLL} "${${_FILE_WITHOUT_EXT}_DLL_FILE}")
    else()
        message(WARNING "Could not find DLL file relative to ${${_LIB}}")
        set(${_DLL} "-NOTFOUND")
    endif()
endmacro()

set(CMAKE_OSX_DEPLOYMENT_TARGET "10.15")
set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
.if global.project_useIngescape
# By overriding CXX FLAGS with O2, we remove the ndebug flags, added by default
# ndebug flags remove asserts which can cause issues if you call a function into an assert
SET(CMAKE_CXX_FLAGS_RELEASE "-O2")
.endif
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Check compiler flags availability before setting them
if (NOT MSVC)
    include(CheckCXXCompilerFlag)
    include(CheckCCompilerFlag)
    foreach(_OPT
            -fPIC
            -pipe
            -pedantic
            -Wall
            -Wextra
            -W
            -Wpointer-arith
            -Wwrite-strings
            -Wunused
            -Wshadow
            -Winline
            -Wnested-externs
            -Wno-long-long
            -Wfloat-equal
            -Wno-multichar
            -Wsign-compare
            -Wundef
            -Wno-format-nonliteral
            -Wendif-labels
            -Wstrict-prototypes
            -Wstrict-aliasing=3
            -Wcast-align
            -Wtype-limits
            -Wold-style-declaration
            -Wmissing-parameter-type
            -Wempty-body
            -Wclobbered
            -Wignored-qualifiers
            -Wconversion
            -Wno-sign-conversion
            -Wvla
            -Wdouble-promotion
            -Wno-system-headers
            -Wno-pedantic-ms-format)
        # CHECK_C_COMPILER_FLAG needs a new variable to store each new test result in.
        check_cxx_compiler_flag(${_OPT} OPT${_OPT}_CXX)
        if(OPT${_OPT}_CXX)
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${_OPT}")
        endif()
        check_c_compiler_flag(${_OPT} OPT${_OPT}_C)
        if(OPT${_OPT}_C)
          set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${_OPT}")
        endif()
    endforeach()
else (NOT MSVC)
    add_definitions(-DNOMINMAX) # Do not define min/max macros
endif(NOT MSVC)

find_package(Qt6 COMPONENTS
    Concurrent
    Core
    Gui
    Quick
    QuickControls2Impl
    QuickLayouts
    QuickTemplates2
    Svg
    Test
    Widgets
    Xml
    REQUIRED
)

.if global.project_useIngescape
# Find ingescape dependency
find_package(sodium)
find_package(ZeroMQ 4.3 REQUIRED)
find_package(czmq 4.2 REQUIRED)
find_package(zyre 2.0 REQUIRED)
find_package(ingescape 4 REQUIRED)
.endif

if (${CI_PIPELINE_ID})
    math(EXPR pipeline_id "${CI_PIPELINE_ID}" OUTPUT_FORMAT DECIMAL)
else()
    set(pipeline_id "0")
endif()

if (APPLE)
    math(EXPR pipeline_id1 "${pipeline_id} / 1000" OUTPUT_FORMAT DECIMAL)
    math(EXPR pipeline_id2 "${pipeline_id} % 1000" OUTPUT_FORMAT DECIMAL)
    set(pipeline_id "${pipeline_id1}.${pipeline_id2}")
endif ()

# Macro to get project version from pro file
macro(get_app_version _MAJOR _MINOR _PATCH)
    file(READ ${CMAKE_CURRENT_SOURCE_DIR}/$(global.project_name:pascal).pro _DOT_PRO_CONTENT)
    string(REGEX MATCH "VERSION_MAJOR = ([0-9]*)" _ ${_DOT_PRO_CONTENT})
    set(${_MAJOR} ${CMAKE_MATCH_1})
    string(REGEX MATCH "VERSION_MINOR = ([0-9]*)" _ ${_DOT_PRO_CONTENT})
    set(${_MINOR} ${CMAKE_MATCH_1})
    string(REGEX MATCH "VERSION_PATCH = ([0-9]*)" _ ${_DOT_PRO_CONTENT})
    set(${_PATCH} ${CMAKE_MATCH_1})
endmacro()

get_app_version(APP_VERSION_MAJOR APP_VERSION_MINOR APP_VERSION_PATCH)
set(APP_VERSION_STRING "${APP_VERSION_MAJOR}.${APP_VERSION_MINOR}.${APP_VERSION_PATCH}")

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/../builds/cmake/modules")
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/../builds/cmake/modules/windows")


########################################################################
# sources list
########################################################################

# Note: sub directories will add also their own source list to this one
set( SOURCE_LIST
    ${CMAKE_CURRENT_LIST_DIR}/$(global.project_name:camel,lower).qrc
    ${CMAKE_CURRENT_LIST_DIR}/main.cpp
.if global.project_useQmlInstrument
    ${CMAKE_CURRENT_LIST_DIR}/qmlinstrument.cpp
    ${CMAKE_CURRENT_LIST_DIR}/qmlinstrument.h
.endif
.if global.project_hasGraphics & !(global.project_useI2Quick)
    ${CMAKE_CURRENT_LIST_DIR}/qmlhotreloader.cpp
    ${CMAKE_CURRENT_LIST_DIR}/qmlhotreloader.h
.endif
)


########################################################################
# executable
########################################################################

qt_add_executable(${PROJECT_NAME} WIN32 MACOSX_BUNDLE ${SOURCE_LIST})

# set executable name
set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "$(global.project_name)")


########################################################################
# sub directories
########################################################################

.if global.project_hasPackages
include(packages/packages.cmake)
.endif
.if global.project_hasGraphics
include(graphics/I2SketchQuick/builds/I2SketchQuickHelper.cmake)
add_i2sketchquick_to_target(${PROJECT_NAME})
.   for project.graphics
.       for graphics.graphic
.           for graphic.app
include(graphics/$(app.name:Pascal)App/$(app.name:Pascal)App.cmake)
add_$(toLowercase(app.name))app_to_target(${PROJECT_NAME})
.           endfor
.           for graphic.library
include(graphics/$(library.name:Pascal)/$(library.name:Pascal).cmake)
add_$(toLowercase(library.name))_to_target(${PROJECT_NAME})
.           endfor
.       endfor
.   endfor
.endif
.if global.project_hasAgents
include(agents/agents.cmake)
.endif

.if (global.project_useI2Quick)
include(${CMAKE_CURRENT_SOURCE_DIR}/../internal/I2Quick/builds/I2QuickHelper.cmake)
add_i2quick_to_target(${PROJECT_NAME})
.endif

target_compile_definitions(${PROJECT_NAME} PRIVATE VERSION="${APP_VERSION_STRING}")
target_compile_definitions(${PROJECT_NAME} PRIVATE APP_NAME="$(global.project_name)")

target_compile_definitions(${PROJECT_NAME}
    PRIVATE
        $<$<OR:$<CONFIG:Debug>,$<CONFIG:RelWithDebInfo>>:QT_QML_DEBUG>)

target_include_directories(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

target_link_libraries(${PROJECT_NAME}
  PRIVATE
  Qt6::Concurrent
  Qt6::Core
  Qt6::CorePrivate
  Qt6::Gui
  Qt6::Quick
  Qt6::QuickLayouts
.if global.project_useI2Quick
  Qt6::QuickPrivate
  Qt6::QuickControls2Impl
  Qt6::QuickTemplates2
.endif
.if (global.project_useI2Quick | global.project_hasGraphics)
  Qt6::QuickTemplates2Private
.endif
  Qt6::QuickLayouts
  Qt6::Svg
  Qt6::Test
  Qt6::Widgets
.if global.project_useIngescape
  czmq
  ingescape
.endif
)

if (APPLE)
    target_link_libraries(${PROJECT_NAME} PRIVATE "-framework Foundation -framework AppKit")
elseif (WIN32)
    target_link_libraries(${PROJECT_NAME} PRIVATE Wtsapi32 user32 Advapi32)
endif()

# Retrieve the absolute path to qmake and then use that path to find the binaries
get_target_property(_qmake_executable Qt6::qmake IMPORTED_LOCATION)
get_filename_component(_qt_bin_dir "${_qmake_executable}" DIRECTORY)

if (APPLE)
    # Uncomment when there is an icon
    # target_sources(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_LIST_DIR}/icon.icns)
    # set_source_files_properties("${CMAKE_CURRENT_LIST_DIR}/icon.icns" PROPERTIES MACOSX_PACKAGE_LOCATION Resources)

    set_target_properties(${PROJECT_NAME} PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/macos-Info.plist.in)
    # Mac OS X bundle specific settings
    set(MACOSX_BUNDLE_BUNDLE_NAME "${PROJECT_NAME}")
    set(MACOSX_BUNDLE_INFO_STRING "${PROJECT_NAME} ${APP_VERSION_STRING}")
    set(MACOSX_BUNDLE_LONG_VERSION_STRING "${APP_VERSION_STRING}")
    set(MACOSX_BUNDLE_SHORT_VERSION_STRING "${APP_VERSION_MAJOR}")
    set(MACOSX_BUNDLE_BUNDLE_VERSION "${APP_VERSION_STRING}")
    # set(MACOSX_BUNDLE_ICON_FILE "icon") # Uncomment when there is an icon
    set(MACOSX_BUNDLE_COPYRIGHT "$(global.project_copyright)")

    # NB: macdeployqt only runs qmlimportscanner correctly when run from Qt bin directory
    find_program(MACDEPLOYQT_EXECUTABLE macdeployqt HINTS "${_qt_bin_dir}")
    add_custom_command(TARGET ${PROJECT_NAME}
        POST_BUILD
        COMMAND cd ${_qt_bin_dir} && "${MACDEPLOYQT_EXECUTABLE}" "$<TARGET_FILE_DIR:${PROJECT_NAME}>/../.." -qmldir="${CMAKE_CURRENT_LIST_DIR}" -no-strip
        COMMENT "Deploying Qt..."
    )

    set(CMAKE_SKIP_INSTALL_RPATH TRUE)
elseif (WIN32)
    if(MSVC) # Check if we are using the Visual Studio compiler
        # This line avoid the appearance of a console windows when runnin the GUI program
        set_target_properties(${PROJECT_NAME} PROPERTIES LINK_FLAGS "/ENTRY:mainCRTStartup")
    endif(MSVC)

    configure_file(${CMAKE_CURRENT_LIST_DIR}/../builds/cmake/modules/windows/$(global.project_name:pascal,lower)_version.rc.in ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.rc)
    target_sources(${PROJECT_NAME}
        PRIVATE
            "${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.rc"
    )

    if(MSVC)
        file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/stable.cpp "#include <stable.h>")
        target_compile_options(${PROJECT_NAME} PRIVATE /Yu"stable.h" /FI"stable.h" /Fp${CMAKE_CURRENT_BINARY_DIR}/stable.pch)
        set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/stable.cpp
            PROPERTIES
                COMPILE_FLAGS "/Yc\\"stable.h\\" /Fp\\"${CMAKE_CURRENT_BINARY_DIR}/stable.pch\\""
                OBJECT_OUTPUTS "${CMAKE_CURRENT_BINARY_DIR}/stable.pch"
        )
        target_sources(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/stable.cpp)
    endif()

.if global.project_useIngescape
    # Copy ingescape and its dependencies
    message(STATUS "ZeroMQ DLL from CMake target: ${ZeroMQ_LIBRARY}")
    find_library(SODIUM_LIB sodium)
    _find_dll_from_lib(SODIUM_LIB SODIUM_DLL)
    find_library(CZMQ_LIB czmq)
    _find_dll_from_lib(CZMQ_LIB CZMQ_DLL)
    find_library(ZYRE_LIB zyre)
    _find_dll_from_lib(ZYRE_LIB ZYRE_DLL)
    find_library(IGS_LIB ingescape)
    _find_dll_from_lib(IGS_LIB IGS_DLL)

    add_custom_command(
        TARGET ${PROJECT_NAME}
        POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
			"${ZeroMQ_LIBRARY}"
			"${SODIUM_DLL}"
			"${CZMQ_DLL}"
			"${ZYRE_DLL}"
			"${IGS_DLL}"
			$<TARGET_FILE_DIR:${PROJECT_NAME}>
    )

	install(FILES
			"${ZeroMQ_LIBRARY}"
			"${SODIUM_DLL}"
			"${CZMQ_DLL}"
			"${ZYRE_DLL}"
			"${IGS_DLL}"
			DESTINATION .)
.endif

    if (CMAKE_BUILD_TYPE STREQUAL "Release")
        include(Windeploy)
        windeployqt(${PROJECT_NAME} ${CMAKE_CURRENT_LIST_DIR})
    endif ()
else ()
    #TODO Add unix target
endif ()

########################################################################
# installer
########################################################################
# Package installer just for release build
# NOTE: Windows packaging has been moved to the packaging directory
#       See .gitlab-ci.yml for commands to generate the Windows NSIS installer
if (CMAKE_BUILD_TYPE STREQUAL "Release")
    install(TARGETS ${PROJECT_NAME} DESTINATION .)

    set(CPACK_MONOLITHIC_INSTALL ON)
    set(CPACK_PACKAGE_NAME "${PROJECT_NAME}")
    set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "${PROJECT_NAME}")
    set(CPACK_PACKAGE_VENDOR "Ingenuity IO")
    set(CPACK_PACKAGE_CONTACT "contact@ingenuity.io")
    set(CPACK_PACKAGE_VERSION ${APP_VERSION_STRING})
    set(CPACK_PACKAGE_VERSION_MAJOR "${APP_VERSION_MAJOR}")
    set(CPACK_PACKAGE_VERSION_MINOR "${APP_VERSION_MINOR}")
    set(CPACK_PACKAGE_VERSION_PATCH "${APP_VERSION_PATCH}")
    set(CPACK_PACKAGE_INSTALL_DIRECTORY "${CPACK_PACKAGE_NAME}")

    if (APPLE)
        set(CPACK_GENERATOR "DragNDrop")
    elseif(WIN32)
        set(CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL ON)
        set(CPACK_NSIS_MUI_FINISHPAGE_RUN ${CPACK_PACKAGE_NAME}.exe)
        set(CPACK_GENERATOR "NSIS;ZIP")
    else ()
        #TODO Add unix target
    endif ()

    set(CPACK_PACKAGE_EXECUTABLES "${PROJECT_NAME}" "${PROJECT_NAME}")
    set(CPACK_CREATE_DESKTOP_LINKS "${PROJECT_NAME}" "${PROJECT_NAME}")

    include (CPack)
endif()

########################################################################
# summary
########################################################################
message ("")
message (STATUS "******************* Configuration Summary *******************")
message (STATUS "General:")
message (STATUS "  System            :   ${CMAKE_SYSTEM_NAME}")
message (STATUS "  CXX compiler      :   ${CMAKE_CXX_COMPILER}")
message (STATUS "")
message (STATUS "Dependencies:")
include(FeatureSummary)
feature_summary (WHAT ALL FATAL_ON_MISSING_REQUIRED_PACKAGES)

.
.####################################################################################
.echo "Generating src/macos-Info.plist.in..."
.output "src/macos-Info.plist.in"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>${MACOSX_BUNDLE_EXECUTABLE_NAME}</string>
	<key>CFBundleGetInfoString</key>
	<string>${MACOSX_BUNDLE_INFO_STRING}</string>
	<key>CFBundleIconFile</key>
	<string>${MACOSX_BUNDLE_ICON_FILE}</string>
	<key>CFBundleIdentifier</key>
	<string>${MACOSX_BUNDLE_GUI_IDENTIFIER}</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleLongVersionString</key>
	<string>${MACOSX_BUNDLE_LONG_VERSION_STRING}</string>
	<key>CFBundleName</key>
	<string>${MACOSX_BUNDLE_BUNDLE_NAME}</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>${MACOSX_BUNDLE_SHORT_VERSION_STRING}</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>${MACOSX_BUNDLE_BUNDLE_VERSION}</string>
	<key>CSResourcesFileMapped</key>
	<true/>
	<key>NSHumanReadableCopyright</key>
	<string>${MACOSX_BUNDLE_COPYRIGHT}</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
	<key>NSSupportsAutomaticGraphicsSwitching</key>
	<true/>
	<key>NSHighResolutionCapable</key>
	<true/>
</dict>
</plist>

.
.####################################################################################
.if global.project_hasGraphics & !(global.project_useI2Quick)
.echo "Copying qmlhotreloader.cpp and qmlhotreloader.h"
.copyFile("$(global.project_scriptFolder)/sketch2Qml/I2SketchQuick/src/Helpers/qmlhotreloader.cpp", "src/qmlhotreloader.cpp")
.copyFile("$(global.project_scriptFolder)/sketch2Qml/I2SketchQuick/src/Helpers/qmlhotreloader.h", "src/qmlhotreloader.h")
.endif
.####################################################################################
.echo "Generating src/main.cpp..."
.output "src/main.cpp"
/*
 *  $(global.project_name)
 *
 *  $(global.project_copyright)
 *
 *  See license terms for the rights and conditions
 *  defined by copyright holders.
 *
 *  Contributors:
.if (defined (definition.author))
 *      $(definition.author)
.endif
 *
 */

#include <QtGlobal>
#include <QDebug>
#include <QApplication>
#include <QQmlApplicationEngine>
#include <QSurfaceFormat>
#include <QStyleHints>

#ifdef INGESCAPE_FROM_PRI
#include "ingescape.h"
#else
#include <ingescape/ingescape.h>
#endif // INGESCAPE_FROM_PRI

#include <array>
#include <csignal>
#include <cstdlib>
#include <iostream>

.if (global.project_useI2Quick)
#include "I2Quick.h"

.endif
.for project.agents
.   for agents.definition
#include "agents/$(definition.name:camel,lower).h"
.   endfor
.endfor
.if project_hasGraphics

#include "i2sketchquick.h"
.   for project.graphics
.       for graphics.graphic
.           for graphic.app
#include "graphics/$(graphic.name:Pascal)App/$(graphic.name:camel,lower)app_qml.h"
.           endfor
.           for graphic.library
#include "graphics/$(graphic.name:Pascal)/$(graphic.name:camel,lower)_qml.h"
.           endfor
.       endfor
.   endfor

.endif

.if global.project_useQmlInstrument
#include "qmlinstrument.h"
.endif
.if global.project_hasGraphics & !(global.project_useI2Quick)
#include "qmlhotreloader.h"
.endif



//--------------------------------------------------------------------------------------
//
// Exceptions & signal handlers
//
//--------------------------------------------------------------------------------------
struct signalInfo {
    int value;
    const char* description;
};


static const std::array<signalInfo, 6> signalInfos {
    {
        { SIGABRT, "SIGABRT: abnormal termination condition"},
        { SIGFPE, "SIGFPE: erroneous arithmetic operation a.k.a. floating point exception"},
        { SIGILL, "SIGILL: invalid instruction"},
        { SIGINT, "SIGINT: external interrupt"},
        { SIGSEGV, "SIGSEGV: invalid memory access a.k.a. segmentation fault"},
        { SIGTERM, "SIGTERM: termination request"}
    }
};


static std::terminate_handler previousTerminate {};


const char *signalDescription(const int signal)
{
    auto findSignalIt = std::find_if(signalInfos.begin(), signalInfos.end(),
                                     [signal](const signalInfo &info) {
                                         return info.value == signal;
                                     });

    if (findSignalIt != signalInfos.end())
        return (*findSignalIt).description;

    return "Unhandled signal";
}


// Application events callback
void onApplicationCrashed()
{
    qInfo() << Q_FUNC_INFO;
}


void onApplicationKilled()
{
    qInfo() << Q_FUNC_INFO;
    igs_stop();
}


void resetSignalHandlers()
{
    std::signal(SIGABRT, SIG_DFL);
    std::signal(SIGFPE, SIG_DFL);
    std::signal(SIGILL, SIG_DFL);
    std::signal(SIGINT, SIG_DFL);
    std::signal(SIGSEGV, SIG_DFL);
    std::signal(SIGTERM, SIG_DFL);
}


void signalHandler(int signal)
{
    std::cout << APP_NAME << " was ended forcefully as a result of signal (" << signal
              << ", " << signalDescription(signal) << ")" << std::endl;

    try
    {
        switch(signal)
        {
            case SIGABRT:
            case SIGSEGV:
            case SIGILL:
            case SIGFPE:
                onApplicationCrashed();
                break;

            case SIGINT:
            case SIGTERM:
                onApplicationKilled();
                break;

            default:
                std::cout << "Unhandled signal in main.cpp:signalHandler:" << signal << std::endl;
                break;
        }
    }
    catch (const std::exception& e)
    {
        std::cout << "Exception in main.cpp:signalHandler:" << e.what() << std::endl;
    }
    catch (...)
    {
        std::cout << "Unknown exception in main.cpp:signalHandler" <<std::endl;
    }

#ifdef QT_DEBUG
    // We rethrow this signal to use the debugger of Qt Creator or the crash reporting system of our OS
    resetSignalHandlers();
    std::raise(signal);
#endif
}



//--------------------------------------------------------------------------------------
//
// Misc.
//
//--------------------------------------------------------------------------------------

.if global.project_useIngescape
void externalStop_Callback(void* myData)
{
    Q_UNUSED(myData)
    QCoreApplication::quit();
}
.endif


static QtMessageHandler previousQtMessageHandler = nullptr;
void igsMessageOutput(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
    QByteArray localMsg = msg.toLocal8Bit();
    const char *file = context.file ? context.file : "";
    const char *function = context.function ? context.function : "";

    switch (type) {
        case QtDebugMsg:
            igs_debug("%s (%s:%u, %s)", localMsg.constData(), file, context.line, function);
            break;
        case QtInfoMsg:
            igs_info("%s (%s:%u, %s)", localMsg.constData(), file, context.line, function);
            break;
        case QtWarningMsg:
            igs_warn("%s (%s:%u, %s)", localMsg.constData(), file, context.line, function);
            break;
        case QtCriticalMsg:
            igs_error("%s (%s:%u, %s)", localMsg.constData(), file, context.line, function);
            break;
        case QtFatalMsg:
            igs_fatal("%s (%s:%u, %s)", localMsg.constData(), file, context.line, function);
            break;
    }

#ifdef QT_DEBUG
    if (previousQtMessageHandler)
        (*previousQtMessageHandler)(type, context, msg);
#endif
}
.if global.project_hasAgents


// Extra QML types and Qt Objects
void registerCustomTypes()
{
.   for project.agents
.       for agents.definition
    qmlRegisterSingletonType<$(definition.name:pascal)>("$(global.project_name:pascal)", 1, 0, "$(definition.name:pascal)", &$(definition.name:pascal)::qmlSingleton);
.       endfor
.   endfor
}
.endif


int main(int argc, char *argv[])
{
#ifdef Q_OS_WIN
    // NB: this line is mandatory and without it, Ingescape will not be able to use
    //     network devices which name contains diacritics when Windows uses UTF-8 as
    //     system locale (i.e. Windows is configured for worldwide language support)
    setlocale(LC_ALL, "");
#endif

    //------------------------------
    // Configure Qt
    //------------------------------
#ifdef QT_DEBUG
    // Print out general information about various parts of the scene graph and the graphics stack
    QLoggingCategory::setFilterRules("qt.scenegraph.general = true");
    qSetMessagePattern("[%{time hh:mm:ss.zzz}][%{type}] %{if-category}%{category}: %{endif}file://%{file}:%{line} - %{message}");
#endif

    // Redirect qLogs to igs logs
    previousQtMessageHandler = qInstallMessageHandler(igsMessageOutput);


    //------------------------------
    // Configure our application
    //------------------------------

    // Change focus behaviors for tab navigation
    QGuiApplication::styleHints()->setTabFocusBehavior(Qt::TabFocusAllControls);

    QGuiApplication app(argc, argv);
    QGuiApplication::setApplicationName(APP_NAME);
    QGuiApplication::setApplicationVersion(VERSION);

    // MSAA 4x
    QSurfaceFormat surfaceFormat;
    surfaceFormat.setSamples(4);
    QSurfaceFormat::setDefaultFormat(surfaceFormat);

    //------------------------------
    // Handle unexpected termination
    //------------------------------

    previousTerminate = std::get_terminate();
    std::set_terminate([](){
        std::cout << APP_NAME << " was ended forcefully due to an unhlandhed exception" << std::endl;

        try
        {
            onApplicationCrashed();
        }
        catch (const std::exception& e)
        {
            std::cout << "Exception in main.cpp at line" << __LINE__ << ":" << e.what() << std::endl;
        }
        catch (...)
        {
            std::cout << "Unknown exception in main.cpp at line" << __LINE__ << ":" << std::endl;
        }

#ifdef QT_DEBUG
        resetSignalHandlers();
        if (previousTerminate) previousTerminate();
#endif
    });

    std::signal(SIGABRT, signalHandler);
    std::signal(SIGFPE, signalHandler);
    std::signal(SIGILL, signalHandler);
    std::signal(SIGINT, signalHandler);
    std::signal(SIGSEGV, signalHandler);
    std::signal(SIGTERM, signalHandler);

    //------------------------------
    // Configure our QML engine
    //------------------------------
    QQmlApplicationEngine engine;
.if (global.project_useI2Quick)
    I2Quick::init(&engine);
.endif
.if project_hasGraphics
    I2SketchQuick::registerTypes();
.   for project.graphics
.       for graphics.graphic
.           for graphic.app
    $(graphic.name:Pascal)AppQml::registerTypes();
.           endfor
.           for graphic.library
    $(graphic.name:Pascal)Qml::registerTypes();
.           endfor
.       endfor
.   endfor
.endif
.if global.project_hasAgents
    registerCustomTypes();
.endif
.if global.project_hasGraphics | global.project_useI2Quick
.   if global.project_useI2Quick
.       global.qmlHotReloader = "I2QmlHotReloader"
.   else
.       global.qmlHotReloader = "QmlHotReloader"
    qmlRegisterSingletonType<QmlHotReloader>("$(global.project_name:pascal)", 1, 0, "QmlHotReloader", &QmlHotReloader::qmlSingleton);
.   endif

    $(global.qmlHotReloader)::instance().setengine(&engine);
    $(global.qmlHotReloader)::instance().seturl(QUrl("qrc:/qml/Content.qml"));

#ifdef QT_DEBUG
    auto sourceDirPath = QFileInfo(QFINDTESTDATA(__FILE__)).absolutePath();
    $(global.qmlHotReloader)::instance().addRootDirPath(sourceDirPath);
    $(global.qmlHotReloader)::instance().watchDirPath(QString("%1%2qml").arg(sourceDirPath).arg(QDir::separator()));
    $(global.qmlHotReloader)::instance().watchDirPath(QString("%1%2resources").arg(sourceDirPath).arg(QDir::separator()));

    // add graphics directories
    $(global.qmlHotReloader)::instance().watchDirPath(QString("%1%2graphics").arg(sourceDirPath, QDir::separator()));
    // - I2SketchQuick
    $(global.qmlHotReloader)::instance().addRootDirPath(QString("%1%2graphics%2I2SketchQuick%2src%2I2SketchQuick").arg(sourceDirPath, QDir::separator()));
.   if (count(project.graphics) > 0)
    // - custom sketch modules
.       for project.graphics
.           for graphics.graphic
.               for graphic.app
    $(global.qmlHotReloader)::instance().addRootDirPath(QString("%1%2graphics%2$(graphic.name:Pascal)App").arg(sourceDirPath, QDir::separator()));
.               endfor
.               for graphic.library
    $(global.qmlHotReloader)::instance().addRootDirPath(QString("%1%2graphics%2$(graphic.name:Pascal)").arg(sourceDirPath, QDir::separator()));
.               endfor
.           endfor
.       endfor
.   endif

    $(global.qmlHotReloader)::instance().start();
#endif
.endif # global.project_hasGraphics

.if global.project_useQmlInstrument
    QmlInstrument qmlInstrument;
.endif

.if project_hasAgents
    // Agents initialisation
.   for project.agents
.       for agents.definition
    $(definition.name:Pascal)::instance();
.       endfor
.   endfor
.endif


.if global.project_useIngescape
    //------------------------------
    // Ingescape agent configuration
    //------------------------------
    igs_set_command_line_from_args(argc, const_cast<const char**>(argv));
    igs_log_set_console(true);
    igs_log_set_file(true, nullptr);

#ifdef QT_DEBUG
    igs_log_set_console_level(IGS_LOG_DEBUG);
#else
    igs_log_set_console_level(IGS_LOG_INFO);
#endif

    char **devices = nullptr;
    char **addresses = nullptr;
    int nbD = 0;
    int nbA = 0;
    devices = igs_net_devices_list(&nbD);
    addresses = igs_net_addresses_list(&nbA);
    Q_ASSERT(nbD == nbA);

    int networkPort = $(project.defaultPort);
    QString networkDevice = "$(project.defaultDevice)";

    bool deviceIsViable = false;
    for(int i(0) ; (i < nbD) && !deviceIsViable ; ++i)
        deviceIsViable = (networkDevice == QString::fromLocal8Bit(devices[i]));

    if (deviceIsViable)
        qInfo() << "using following network device (" << networkDevice << ")";
    else
    {
        if (nbD == 1)
        {
            //exactly one compliant network device available: we use it
            networkDevice = QString::fromLocal8Bit(devices[0]);
            qInfo() << "using" << networkDevice << "as default network device (this is the only one available)";
        }
        else if ((nbD == 2)
                && ((strcmp(addresses[0], "127.0.0.1") == 0)
                    || (strcmp(addresses[1], "127.0.0.1") == 0)))
        {
            //two devices, one of which is the loopback
            //pick the device that is NOT the loopback
            const char* selectedDevice = (strcmp(addresses[0], "127.0.0.1") == 0) ? devices[1] : devices[0];
            networkDevice = QString::fromLocal8Bit(selectedDevice);
            qInfo() << "using" << networkDevice << "as default network device (this is the only one available that is not the loopback)";
        }
        else
        {
            if (nbD == 0)
                qWarning() << "No network device found: aborting.";
            else
                qWarning() << "Several network devices available. None will be selected by default.";
        }
    }

    igs_free_net_devices_list(devices, nbD);
    igs_free_net_addresses_list(addresses, nbD);

    igs_observe_forced_stop(externalStop_Callback, nullptr);

    igs_debug("Ingescape version: %d (protocol v%d)", igs_version(), igs_protocol());

    igs_start_with_device(networkDevice.toLocal8Bit().toStdString().c_str(), networkPort);

.endif

    //------------------------------
    // Start our application
    //------------------------------
    const QUrl url(QStringLiteral("qrc:/qml/main.qml"));
    QObject::connect(&engine, &QQmlApplicationEngine::objectCreated,
.if global.project_useQmlInstrument
        &app, [url, &qmlInstrument, &engine](QObject *obj, const QUrl &objUrl) {
.else
        &app, [url](QObject *obj, const QUrl &objUrl) {
.endif
            if (!obj && url == objUrl)
            {
                qWarning() << "Invalid QML";
                QCoreApplication::exit(-1);
                return;
            }

.if global.project_useQmlInstrument
            qmlInstrument.setRootObject(engine.rootObjects().at(0));
.endif
        }, Qt::QueuedConnection);
    engine.load(url);

    QObject::connect(qGuiApp, &QGuiApplication::aboutToQuit, []()
    {
        qInfo() << "Application about to quit";
        igs_stop();
    });

    qInfo() << "Starting" << QGuiApplication::applicationName() << QGuiApplication::applicationVersion() << "with processID" << QGuiApplication::applicationPid();
    int exitCode = app.exec();
    qInfo() << "Quitting application with exit code" << exitCode;

    return exitCode;
}

.
.####################################################################################
.echo "Generating src/stable.h..."
.output "src/stable.h"
$(global.project_generateCopyright(global.project_name, global.project_contributor))

/* Add C includes here */


/* Add C++ includes here */
#if defined __cplusplus

#ifdef _WIN32
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif

    #ifndef NOMINMAX
        #define NOMINMAX
    #endif
    #include <windows.h>
    #include <winsock2.h>
#endif

#include <iostream>

#include <QtCore>
#include <QtGui>
#include <QtQml>
#include <QtQuick>

#endif

.####################################################################################
.echo "Generating src/$(global.project_name:camel,lower).qrc..."
.output "src/$(global.project_name:camel,lower).qrc"
<RCC>
    <qresource prefix="/">
        <file>qml/main.qml</file>
        <file>qml/Content.qml</file>
.if global.project_hasGraphics
        <file>qml/Page.qml</file>
.   for project.graphics
.       for graphics. as graphic
.           for graphic.app where graphicAppHasScreen(app)
        <file>qml/$(graphic.name:pascal)Page.qml</file>
.           endfor
.       endfor
.   endfor
.endif
    </qresource>
</RCC>
.
.####################################################################################
.echo "Generating src/qml/main.qml..."
.output "src/qml/main.qml"
import QtQuick
import QtQuick.Window
import QtQuick.Controls

.if (global.project_useI2Quick)
import I2Quick

.endif
.if global.project_hasGraphics
import $(global.project_name:pascal)
.   if (count(project.graphics) > 0)

.       for project.graphics
.           for graphics. as graphic
.               for graphic.app where graphicAppHasScreen(app)
import $(qmlModuleName("$(graphic.name)"))
import $(qmlModuleName("$(graphic.name)App"))

.               endfor
.           endfor
.       endfor
.   endif
.endif


ApplicationWindow {
    id: root

    title: qsTr("%1 - v%2").arg(Qt.application.displayName).arg(Qt.application.version)
    visible: true

    width: 1920
    height: 1080
    minimumWidth: 1024
    minimumHeight: 768

.if global.project_hasGraphics
    color: "#2c3e50"
.else
    color: "white"
.endif

.if (global.project_useI2Quick)
    function takeSnapshot() {
        takeSnapshotWithCustomPixelRatio(Screen.devicePixelRatio);
    }

    function takeSnapshotWithCustomPixelRatio(pixelRatio) {
        snapshotBackground.visible = true;
        content.Window.contentItem.grabToImage(function(result) {
            snapshotBackground.visible = false;
            if (I2SnapshotHelper.saveItemGrabResult(result, Qt.application.name, "-yyyy-MM-dd--hh-mm-ss-zzz" + ((pixelRatio > 1) ? ".@" + pixelRatio + "x" : "")))
                snapshotFeedbackAnimation.restart();
        }, Qt.size(content.width * pixelRatio, content.height * pixelRatio));
    }
.endif

    Component.onCompleted: {
.if (count(project.graphics) > 0)
        // Load fonts
.   for project.graphics
.       for graphics. as graphic
.           for graphic.app where graphicAppHasScreen(app)
        $(graphic.name:Pascal)FontLoaders.load();
        $(graphic.name:Pascal)AppFontLoaders.load();

.           endfor
.       endfor
.   endfor
.endif
        // Load our QML content
        loaderAnimation.start();
    }

    Item {
        id: content
        anchors.fill: parent

.if (global.project_useI2Quick)
        Rectangle {
            id: snapshotBackground
            anchors.fill: parent
            visible: false
            color: root.color
        }

.endif
        Text {
            id: errorMessage
            anchors.fill: parent
            visible: (applicationLoader.status === Loader.Error)
            horizontalAlignment: Text.AlignHCenter
            verticalAlignment: Text.AlignVCenter
            wrapMode: Text.WordWrap
            text: qsTr("Well, this is awkward...\\n\\nThe application has encountered a fatal QML error and can not continue\\n\\n(ಠ_ಠ)")
            color: "#E10600"
            font {
                family: "Arial"
                bold: true
                pixelSize: 72
            }
        }

        Loader {
            id: applicationLoader
            anchors.fill: parent

.if global.project_hasGraphics
            asynchronous: !$(global.qmlHotReloader).isRunning
.else
            asynchronous: true
.endif

            visible: (opacity > 0)
            opacity: (status === Loader.Ready) ? 1 : 0

            Behavior on opacity {
                NumberAnimation {
                    duration: 200
                    easing.type: Easing.OutQuad
                }
            }
        }

        PauseAnimation {
            id: loaderAnimation
            duration: 250
            onStopped: {
.if global.project_hasGraphics | global.project_useI2Quick
                applicationLoader.source = Qt.binding(function() { return $(global.qmlHotReloader).url; });
.else
                applicationLoader.source = "qrc:/qml/Content.qml";
.endif
            }
        }
    }
.if (global.project_useI2Quick)

    Rectangle {
        id: snapshotFeedback

        anchors.fill: parent

        opacity: 0
        visible: (opacity > 0)
    }


    SequentialAnimation {
        id: snapshotFeedbackAnimation

        NumberAnimation {
            target: snapshotFeedback
            property: "opacity"
            duration: 75
            easing.type: Easing.InOutQuad
            to: 0.3
        }

        NumberAnimation {
            target: snapshotFeedback
            property: "opacity"
            duration: 75
            easing.type: Easing.InOutQuad
            to: 0.0
        }
    }

.endif
}
.####################################################################################
.echo "Generating src/qml/Content.qml..."
.output "src/qml/Content.qml"
import QtQuick
import QtQuick.Controls.Basic
import QtQuick.Layouts

.if (global.project_useI2Quick)
import I2Quick
import I2Quick.Controls

.endif
.if global.project_hasAgents
import $(global.project_name:pascal)
.endif

.if global.project_hasGraphics
RowLayout {
    id: root

    Rectangle {
        Layout.fillHeight: true
        Layout.preferredWidth: 160
        color: "#34495e"

        ListView {
            id: menu

            anchors.fill: parent

            model: [
.for project.graphics
.   for graphics.graphic
.       for graphic.app where graphicAppHasScreen(app)
.           if first(graphic)
                "$(qmlModuleName("$(graphic.name)App"))"
.           else
                , "$(qmlModuleName("$(graphic.name)App"))"
.           endif
.       endfor
.   endfor
.endfor
            ]

            delegate: TabButton {
                width: ListView.view.width

                text: modelData

                font {
                    pixelSize: 14
                    bold: true
                }

                palette {
                    window: "#2c3e50"
                    dark: "#34495e"
                    mid: Qt.lighter("#34495e")
                    windowText: "#ecf0f1"
                    brightText: "#ecf0f1"
                }

                checked: (index === menu.currentIndex)

                onClicked: menu.currentIndex = index;
            }
            currentIndex: 0
        }
    }

    StackLayout {
        Layout.fillWidth: true
        Layout.fillHeight: true
        currentIndex: menu.currentIndex
.for project.graphics
.   for graphics. as graphic
.       for graphic.app where graphicAppHasScreen(app)

        $(graphic.name:pascal)Page {}
.       endfor
.   endfor
.endfor
    }
}
.else
Text {
    objectName: "label"
    horizontalAlignment: Text.AlignHCenter
    verticalAlignment: Text.AlignVCenter
    text: qsTr("My UI")
    font {
        pixelSize: 32
        family: "Arial"
    }
    color: "black"
}
.endif
.
.if global.project_hasGraphics
.####################################################################################
.echo "Generating src/qml/Page.qml..."
.output "src/qml/Page.qml"
import QtQuick
import QtQuick.Controls.Basic

Rectangle {
    id: root

    default property alias content: graphicProjectViews.contentData
    property var names: []

    SwipeView {
        id: graphicProjectViews
        // NOTE anchors.fill produce bug when many views are loaded
        width: parent.width
        height: parent.height
        clip: true
        currentIndex: indicator.currentIndex
    }

    PageIndicator {
        id: indicator
        anchors {
            bottom: title.top
            bottomMargin: 8
            horizontalCenter: parent.horizontalCenter
        }
        count: graphicProjectViews.count
        currentIndex: graphicProjectViews.currentIndex
        interactive: true
    }

    Rectangle {
        id: title
        anchors {
            bottom: parent.bottom
            bottomMargin: 16
            horizontalCenter: parent.horizontalCenter
        }
        width: Math.max(nameText.width * 1.2, 80)
        height: 32
        radius: 3
        color: "#34495e"
        opacity: hoverHandler.hovered ? .8 : .4

        Text {
            id: nameText
            anchors.centerIn: parent
            font {
                pixelSize: 14
                bold: true
            }
            color: "#ecf0f1"
            text: root.names[graphicProjectViews.currentIndex]
        }

        HoverHandler {
            id: hoverHandler
        }
    }
}
.
.for project.graphics

.   for graphics. as graphic
.       for graphic.app where graphicAppHasScreen(app)
.####################################################################################
.echo "Generating src/qml/$(graphic.name:pascal)Page.qml..."
.output "src/qml/$(graphic.name:pascal)Page.qml"
import QtQuick
import QtQuick.Controls as C

import $(qmlModuleName("$(graphic.name)App"))

Page {
    id: root

    names: [
.           global.project2cpp_isFirstPageScreen = 1
.           for app.page
.               for page.screen
.                   if global.project2cpp_isFirstPageScreen
        "$(screen.name:pascal)"
.                       global.project2cpp_isFirstPageScreen = 0
.                   else
        , "$(screen.name:pascal)"
.                   endif
.               endfor
.           endfor
    ]

.           if (numberOfScreens(app) < 3)
.               # Optimization to avoid useless Loader items
.               for app.page
.                   for page.screen

    $(screen.name:pascal) {}
.                   endfor
.               endfor
.           else
.               for app.page
.                   for page.screen

    Loader {
        active: C.SwipeView.isCurrentItem || (C.SwipeView.view.contentItem.moving && (C.SwipeView.isPreviousItem || C.SwipeView.isNextItem))
        asynchronous: true
        sourceComponent: $(screen.name:pascal) {}
    }
.                   endfor
.               endfor
.           endif
}
.       endfor
.   endfor
.endfor
.
.endif # global.project.hasGraphics

.endtemplate
